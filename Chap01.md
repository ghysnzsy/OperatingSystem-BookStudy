Chapter01.  컴퓨터 시스템의 소개
01. 컴퓨터 하드웨어의 구성
컴퓨터 시스템 : 하드웨어와 소프트웨어로 구성.
운영체제 : 하드웨어를 관리하는 소프트웨어

하드웨어 : 프로세서, 메모리(기억장치), 주변장치로 구성 -> 각각 시스템 버스로 연결됨

1) 프로세서
프로세서 : 컴퓨터 하드웨어에 부착한 모든 장치의 동작을 제어하고 명령을 실행하는 중앙처리장치(CPU : Central Processing Unit)
- 연산장치, 제어장치, 레지스터로 구성 -> 각각 내부 버스로 연결됨

레지스터 : 프로세서 내 존재하는 고속 메모리. 데이터 처리 중인 중간 결과 등을 프로세서가 바로 사용하기 위해 존재
- 구분
전용 레지스터 / 범용 레지스터 
사용자 가시(user-visible) 레지스터 / 사용자 불가시(user-invisible) 레지스터
데이터 레지스터 / 주소 레지스터 / 상태 레지스터
 
사용자 가시 레지스터 : 사용자가 운영체제와 사용자 프로그램을 이용하여 정보를 변경할 수 있는 레지스터
종류	설명
데이터 레지스터
DR : Data Register	함수 연산에 필요한 데이터를 저장.
값, 문자 등을 저장하고 산순 연산이나 논리 연사에 사용하여
연산 결과로 플래그 값을 저장
주소 레지스터
AR : Address Register	주소나 유효 주소를 계산하는 데 필요한 주소의 일부분을 저장. 주소 레지스터에 저장한 값(값 데이터)을 사용하여 산술 연산을 가능케 함
	기준 주소 레지스터	프로그램을 실행할 때 사용하는 기준 주소 값 저장. 기준 주소는 하나의 프로그램이나 일부처럼 서로 관련 있는 정보를 저장하며, 연속된 저장 공간을 지정하는 데 참조할 수 있는 주소.
페이지나 세그먼트처럼 블록화 된 정보에 접근할 때 사용
	인덱스 레지스터	유효 주소를 계산하는데 사용하는 주소 정보를 저장
	스택 포인터 레지스터	메모리에 프로세서 스택을 구현하는 데 사용.
많은 프로세서와 주소 레지스터를 데이터 스택 포인터와 큐 포인터로 사용.
반환 주소, 프로세서 상태 정보, 서브루틴의 임시 변수를 저장

사용자 불가시 레지스터 : 사용자가 정보를 변경할 수 없는 레지스터. 프로세서의 상태와 제어를 관리

종류	설명
프로그램 카운터
PC : Program Counter	다음에 실행할 명령어의 주소를 보관하는 레지스터
계수기로 되어 있어 실행할 명령어를 메모리에서 읽으면 명령어의 길이만큼 증가하여 다음 명령어를 가리키며, 분기 명령어는 목적 주소로 갱신할 수 있다.
명령어 레지스터
IR : Instruction Register	현재 실행하는 명령어를 보관하는 레지스터

누산기
ACC : Accumulator	데이터를 일시적으로 저장하는 레지스터
메모리 주소 레지스터
MAR : Memory Address Register	프로세서가 참조하려는 데이터의 주소를 명시하여 메모리에 접근하는 버퍼 레지스터
메모리 버퍼 레지스터
MBR : Memory Buffer Register	프로세서가 메모리에서 읽거나 메모리에 저장할 데이터 자체를 보관하는 버퍼 레지스터.
(= Memory Data Register)

2) 메모리
메모리 계층 구조 : 프로그램과 데이터를 보조기억장치에 보관하다가 실행 시에만 메인 메모리, 캐시, 레지스터 순으로 데이터를 옮겨가며 실행. 메모리의 비용 때문에 제안됨
2.2) 메인 메모리
메인 메모리 : 프로세서 외부에 있으며 프로세서에서 수행할 프로그램과 데이터를 저장하거나 프로세서가 처리한 결과를 메인 메모리에 저장. 입출력장치도 동일(=주기억장치. 1차 기억장치)
프로세서 <-> 메인 메모리 <-> 주변장치
주로 DRAM(Dynamic RAM) 사용
메인 메모리는 다수의 셀로 구성되며, 각 셀은 비트로 구성됨. 셀이 K비트라면 셀에 2^k 값을 저장 가능. 셀은 주소로 참조하는데, n비트이라면 주소는 (0~2^n)-1이다.

물리적 변수 : 컴퓨터에 주어진 주소 -> 프로그래머는 물리적 주소 대신 수식이나 변수 사용.
컴파일러가 프로그램을 기계 명령어로 변환할 때 변수와 명령어에 논리적 주소(가상 주소, 프로그램 주소)를 할당
컴파일로 논리적 주소를 물리적 주소로 변환하는데, 이 과정을 매핑(Mapping) 또는 메모리 맵(Memory Map)이라고 함.
논리적 주소(프로그램으로 생성된 가상의 주소) --- 매핑 --> 물리적 주소(실제 주소)

메모리 속도 : 메모리 접근 시간과 메모리 사이클 시간으로 표현
메모리 접근 시간 : 명령이 발생한 후 목표 주소를 검색하여 데이터 쓰기(읽기)를 시작하는 시간
메모리 사이클 시간 : 두 번의 연속적인 메모리 동작 사이에 필요한 최소 지연시간
(ex: 읽기 제어 신호를 가한 후 다음 읽기 제어 신호를 가할 수 있을 때까지 필요한 시간)
보통 사이클 시간이 접근 시간보다 약간 길며, 메모리 세부 구현 방법에 따라 다름.
메인 메모리는 프로세서와 보조 기억장치 사이에 위치. 디스크 입출력 병목 현상 해결하는 역할
메인 메모리와 프로세서와의 속도 차이는 캐시 메모리로 해결함.
2.3) 캐시
프로세서 내부나 외부에 있으며 프로세서와 메인 메모리의 속도 차이를 보완하는 고속 버퍼.
버퍼 : 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관.
캐시는 데이터를 블록 단위로 가져와 프로세서에 워드 단위로 전달하여 속도 차이를 줄임
캐시는 메인 메모리와 크기가 동일한 블록 여러 개로 구성되어 있음. 보통 8~64바이트 크기

캐시의 동작 과정
- 캐시는 주소 영역을 한 번 읽어 들일 수 있는 크기로 나눈 후 각 블록에 번호를 부여하여 이 번호를 태그로 저장함.
- 프로세서는 메인 메모리에 접근하기 전에 캐시에 해당 주소의 자료가 있는지 확인.
- 주소 24비트 중 태그에 해당하는 처음 22비트를 캐시의 모든 라인과 비교하여 일치하는 라인을 찾음
- 일치하는 라인이 있으면, 주소의 나머지 2비트를 이용하여 데이터 라인의 4개 바이트 중 해당하는 바이트를 가져온다.
캐시의 성능은 캐시에 프로세서가 이후 참조할 정보가 얼마나 들어 있는지에 따라 결정됨.
캐시 적중(Cache hit) : 프로세서가 참조하려는 정보가 있을 때 <-> 캐시 실패(Cache miss)
공간적 지역성(spatial locality) : 대부분의 프로그램이 참조한 주소와 인접한 주소의 내용을 다시 참조하는 특성
시간적 지역성(temporal locality) : 한 번 참조한 주소를 곧 다시 참조하는 특성
블록의 크기는 캐시의 성능으로 좌우되는데, 실제 프로그램을 실행할 때 참조한 메모리에 대한 공간적 지역성과 시간적 지역성이 있기 때문
위 특성의 발생 이유
- 프로그램이 명령어를 순차적으로 실행하는 경향이 있어 명령어가 특정 지역 메모리에 인접함.
- 순환(단일 순환, 중첩 순환 등) 때문에 프로그램을 반복하더라도 메모리는 일부 영역만 참조함.
- 대부분의 컴파일러를 메모리에 인접한 블록에 배열로 저장함. 따라서 프로그램이 배열 원소에 순차적으로 자주 접근하므로 지역적인 배열 접근 경향이 있다.

지역성은 블록이 크면 캐시의 히트율이 올라갈 수 있음을 의미하나, 이에 따른 전송 부담과 캐시 데이터 교체 작업이 자주 일어나므로 블록 크기를 무작정 늘릴 수는 없음

2.4) 보조기억장치
주변장치 중 프로그램과 데이터를 저장하는 하드웨어. 2차 저장장치, 외부기억장치

3) 시스템 버스
시스템 버스 : 하드웨어를 물리적으로 연결하여 서로 데이터를 주고받을 수 있게 하는 통로.
컴퓨터 내부의 다양한 신호(데이터 입출력 신호, 프로세서 상태 신호, 인터럽트 요구와 허가 신호, Clock 신호 등)를 시스템 버스로 전달함. 데이터 버스, 주소 버스, 제어 버스로 구분됨.
종류	설명
데이터 버스	프로세서와 메인 메모리, 주변장치 사이에서 데이터를 전송함. 데이터 버스를 구성하는 배선 수는 프로세서가 한 번에 전송할 수 있는 비트 수를 결정하는데, 이를 워드라고 한다.
주소 버스	프로세서가 시스템의 구성 요소를 식별하는 주소 정보를 전송한다. 주소 버스를 구성하는 배선 수는 프로세서와 접속할 수 있는 메인 메모리의 최대 용량을 결정함
제어 버스	프로세서가 시스템의 구성 요소를 제어하는 데 사용함. 제어 신호로 연산장치의 연산 종류와 메인 메모리의 읽기나 쓰기 동작을 결정함

4) 주변장치
주변장치 : 프로세서와 메인 메모리를 제외한 나머지 하드웨어 구성 요소
입력장치, 출력장치, 저장장치로 구분됨
 
02. 컴퓨터 시스템의 동작
컴퓨터 시스템 작업 처리 순서
- 입력장치로 정보를 입력받아 메모리에 저장
- 메모리에 저장한 정보를 프로그램 제어에 따라 인출하여 연산장치에서 처리
- 처리한 정보를 출력장치에 표시하거나 보조기억장치에 저장

명령어와 데이터 – 입력장치로 컴퓨터에 유입되는 정보
명령어 : 실행할 산술, 논리 연상의 동작을 명시하는 문장. 
프로그램 : 어떤 작업을 수행하는 명령어의 집합. 컴파일러 등으로 기계 명령어로 변환함.

1) 명령어의 구조
명령어는 프로세서가 실행할 연산인 연산 부호와 명령어가 처리할 데이터, 데이터를 저장한 레지스터나 메모리 주소인 피연산자로 구성됨. 명령어는 프로세서에 따라 고정길이 or 가변길이 구성.
연산 부호는 일반적으로 한 개. 피연산자는 여러 개 가능
연산부호(Opcode : Operation Code) : 프로세서가 실행할 동작인 연산을 지정.
- 산술연산, 논리연산, 시프트, 보수 등 연산 정의 연산부호가 n비트면 최대 2^n개의 연산 가능.
피연산자(operand) : 연산할 데이터 정보를 저장함. 데이터는 레지스터나 메모리, 가상 기억장치, 입출력장치 등에 위치할 수 있음. 보통 데이터 자체보다는 데이터 위치를 저장함.
보통 연산부호 – 목적지 피연산자(destination operand) – 소스 피연산자(source operand)로 구성됨.

명령어는 실행 전에 메인 메모리에 저장하며, 하나씩 프로세서에 전송하여 해석, 실행됨.
피연산자 수에 따라 0-주소 명령어, 1-주소 명령어, 3-주소 명령어 등으로 구분됨.
누산기 : 메모리에서 읽은 피연산자를 레지스터에 저장된 데이터와 연산할 때 사용하는 프로세서의 레지스터. 프로그램의 명령어 수행 중에 산술, 논리 연산의 결과를 일시적으로 저장.

명령어에 피연산자의 위치를 명시하는 방법을 나타내는 모드 비트(mode bit)를 추가하거나 다음 명령어의 위치를 나타내는 주소를 추가할 수 있음.
직접 주소 – 주소필드에 피연산자의 주소를 직접 지정하는 경우. 모드비트가 0
간접 주소 – 피연산자의 유효 주소가 저장되어 있는 기억장치 주소를 저장. 모드비트가 1.
간접 주소는 총 두 번 메모리를 참조함.

2) 명령어의 실행
명령어의 실행 과정
- 명령어 인출 : 명령어 레지스터에 저장된 다음 명령어를 인출
- 명령어 해석, 프로그램 카운터 변경 : 명령어를 해석하고 다음 명령어를 지정하려고 프로그램 카운터 변경
- 피연산자 인출 : 명령어가 메모리에 있는 워드를 한 개 사용하려면 사용 장소를 결정하여 피연산자를 인출하고, 필요하면 프로세서 레지스터로 보냄
- 명령어 실행
- 결과 저장
- 다음 명령어로 이동

명령어를 인출하여 연산 완료한 시점까지 인출-해석-실행 사이클 또는 인출-실행 사이클이라 함.
명령어 실행 사이클(명령어 실행 주기)라고도 함.
명령어 실행 사이클 : 인출과 실행을 반복하는 것이 일반적인 명령어 사이클

2.1) 인출 사이클
인출 사이클(fetch cycle) : 명령어 실행 사이클의 첫 번째 단계.
메모리에서 명령어를 읽어 명령어 레지스터에 저장하고, 다음 명령어를 실행하려고 프로그램 카운터를 증가시킴.
명령어 인출 시간 : 인출 사이클에 소요되는 시간.


2.2) 실행 사이클
실행 사이클 : 인출한 명령어를 해독하고 그 결과에 따라 제어 신호를 발생시켜 명령어를 실행
실행 시간 : 실행 사이클에서 소비되는 시간

2.3) 간접 사이클
간접 사이클 : 간접 주소 지정 방법을 사용하는 실행 사이클.

2.4) 인터럽트 사이클
인터럽트 : 프로세서가 프로그램을 수행하는 동안 컴퓨터 시스템의 내부나 외부에서 발생하는 예기치 못한 사건
프로세서는 실행 사이클을 완료한 후 인터럽트 요구가 있는지 검사함. 인터럽트 요구가 없으면 다음 명령어를 인출하고, 요구가 있으면 현재 수행 중인 프로그램의 주소(프로그램 카운터) 값을 스택이나 메모리의 0번지와 같은 특정 장소에 저장. 그리고 프로그램 카운터에는 인터럽트 처리 루틴의 시작 주소를 저장해 두었다가 인터럽트 처리를 완료하면 중단된 프로그램으로 복귀하여 계속 수행함.

3) 인터럽트 명령어
인터럽트 : 현재 실행 중인 프로그램을 중단하고 다른 프로그램의 실행을 요구하는 명령어이자 컴퓨터에 설치된 입출력장치나 프로그램 등에서 프로세서로 보내는 하드웨어 신호
시스템의 처리 효율을 향상시키며, 프로그램의 실행 순서를 바꿔 가면서 처리하여 다중 프로그래밍에 사용.
인터럽트를 받은 프로그램은 실행을 중단하고 다른 프로그램을 실행.
사용자가 별도로 인터럽트 조치를 할 필요가 없고 프로세서와 운영체제가 처리함.
컴퓨터는 인터럽트를 외부장치의 동작과 자신의 동작을 조정하는 수단으로 사용함.

인터럽트 요청 회선(IRQ: Interrupt Request line) : 제어 버스 중 인터럽트를 목적으로 사용하는 것.
프로세서가 이벤트 발생 여부를 일일이 감시하지 않아도 됨.(ex: 키보드 입력 시, 인터럽트 발생)

인터럽트 요청과 인터럽트 서비스 루틴으로 구분됨.
인터럽트 서비스 루틴(Interrupt Service routine) : 인터럽트 요청 신호에 따라 수행하는 루틴

인터럽트 요청 회선은 단일 회선과 다중 회선으로 연결할 수 있음.
단일 회선 : 인터럽트 요청이 가능한 모든 장치를 단일 회선으로 프로세서에 연결하는 방법.
인터럽트를 요청한 장치를 판별하는 기능이 필요함.
다중 회선 : 모든 장치를 서로 다른 고유의 회선으로 프로세서와 연결하는 방법.

인터럽트 요청 신호 발생 시, 컴퓨터는 실행 중인 프로그램을 메모리에 저장하고, 인터럽트 처리 프로그램으로 분기함. 처리 완료 후, 인터럽트를 발생시킨 프로그램에 제어를 돌려줌.

서브루틴과의 차이점
서브루틴은 자신을 호출한 프로그램이 요구한 기능을 수행하지만, 인터럽트 처리 프로그램은 현재 실행 중인 프로그램과 관계없을 수 있음.
그래서 인터럽트가 발생할 때의 상태 코드(상태 워드)를 임시 기억장치에 저장해 두었다가 나중에 복귀했을 때 이를 다시 적재해야 한다.
