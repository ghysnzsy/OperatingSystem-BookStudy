# Chapter03. 프로세서와 스레드
## 01. 프로세스의 개념과 상태 변화
### 1) 프로세스의 개념
- 실행 중인 프로그램(가장 일반적인 프로세스 정의 - 자신만의 메모리 영역(주소공간)이 있음을 의미함)
- 비동기적(aynchronous) 행위
- 실행 중인 프로시저
- 실행 중인 프로시저의 제어 추적
- 운영체제에 들어 있는 프로세스 제어 블록(PCB)
- 프로세서에 할당하여 실행할 수 있는 개체 디스패치(dispatch)가 가능한 대상
- 현재의 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동(레지스터 내용)도 포함함.

##### 프로그램
컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 정적인 객체.

##### 프로세스
메모리 구조를 이루고, 프로그램 카운터나 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어 있는 동적인 객체.

사용자 관점에서 프로세스는 주소 공간을 가지고 실행하는 프로그램.

시스템 관점에서 프로세스는 하단 그림과 같이 실행 중인 프로그램.

<그림위치>

실행 순서를 결정하는 스케줄러는 디스크에 저장딘 프로그램에 프로세서를 할당해서 장치나 메모리 같은 파일 자원을 참조함.

그리고 프로세서를 지원하고 협력하여 교착 상태, 보호, 동기화 같은 정보를 교환함.

##### 스택(stack)

데이터를 일시적으로 저장하는 영역. 

지역변수에 사용하고, 변수가 범위 밖으로 이동하면 공간을 해제.

호출한 함수의 반환 주소, 반환 값, 매개변수 등에 사용하고, 함수를 호출할수록 커지고 반환하면 줄어듬.
##### 힙(heap)

코드 영역과는 별도로 유지되는 자유 영역.
동적을오 메모리를 할당하려고 프로그램 실행 중 시싀템 호출을 사용했다가 해제하는 방법으로 활용함.
프로세스의 공유 라이브러리와 동적으로 적재된 모듈이 서로 공유하는데, 동적 메모리 할당이 발생하면 보통 위쪽으로 커짐.
- 스택과 힘 사이늰 서브루틴을 실행하는 영역으로, 운영체제로 매핑되지 않음.
##### 데이터(data)

프로그램의 가상 주소 공간.

전역변수나 정적변수를 저장 또는 할당하고 실행하기 전에 초기화함.

초기화하지 않은 데이터는 데이터 영역의 끝에서 시작함.
##### 코드(code)

실행 명령을 포함하는 메모리 또는 목적 파일에 있는 프로그램 영역.

프로그램을 시작할 때 프로세서가 디스크에서 읽어 실행하는 컴파일한 프로그램을 저장함.

프로세스로 변경할 수 없고, 읽기 전용이므로 프로그램이 코드 영역을 침범하여 쓰기를 시도하면 오류가 발생하여 프로그램이 종료됨.

코드 영역은 공유할 수 있으므로 자주 실행하는 프로그램(워드 프로세서, C 컴파일러, 셀 등)의 사본 하나는 메모리에 존재함.

##### 재진입 프로그램
여러 사용자가 메모리에 있는 동일한 사본을 공유할 수 있는 프로그램. 

프로세스 실행 중에 사용할 데이터를 보관하는 스택 영역과 공통 데이터를 보관하는 데이터 영역으로 나뉘어 있음.

따라서 프로세스 2개가 동일한 문서 편집기를 사용하고 데이터 영역이 같더라도 스택 영역은 서로 달라 별개의 프로세스로 인식함.

##### 프로세스의 종류
<table>
<tr>
<th>
구분
</th>
<th>
종류</th>
<th>
설명</th>
</tr>
<tr>
<td rowspan="2">
역할
</td>
<td>
시스템(커널) 프로세스
</td>
<td>
모든 시스템 메모리와 프로세서의 명령에 액세스할 수 있는 프로세스.

프로세스 실행 순서를 제어하거나 다른 사용자 및 커널(운영체제) 영역을 침범하지 못하게 감시하고, 사용자 프로세스를 생성하는 기능을 함.
</td>
</tr>
<tr>
<td>
사용자 프로세스
</td>
<td>
사용자 코드를 수행하는 프로세스
</td>
</tr>
<tr>
<td rowspan="2">
병행 수행 방법
</td>
<td>
독립 프로세스
</td>
<td>
다른 프로세스에 영향을 주지 않거나 다른 프로세스에 영향을 받지 않으면서 수행하는 병행 프로세스이다.
</td>
</tr>
<tr>
<td>
협력 프로세스</td>
<td>
다른 프로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행 프로세스.
</td>
</tr>
</table>

### 2) 프로세스의 상태 변화와 상태 정보

운영체제는 프로세스의 실행을 제어함. 그리고 상태가 변하는 프로세스 제어에 필요한 상태를 점검하고 제어함.

#### 2.1) 프로세스의 상태 변화
프로세스의 상태 - 실행 상태 <> 비실행 상태

프로세서 생성  시, 비실행 상태로 초기화한 후 실행을 기다림.

실행 중인 프로세스를 종료하거나 인터럽트 발생 시, 비실행 프로세스 중에서 선택한 프로세스를 실행상태로 변경(dispatch)

이 때, 인터럽트된 프로세스는 비실행 상태로 전환.

준비, 실행, 대기(보류)로 더 세분화할 수 있음. 시스템을 떠날 때까지 이 과정을 반복함.

프로세스의 상태 변화는 운영체제가 작업 스케줄러와 프로세스 스케줄러 같은 프로세서 스케줄러를 이용하여 관리함.

작업 스케줄러는 스풀러가 디스크에 저장한 작업 중 실행할 작업을 선정하고 준비 리스트에 삽입하여 다중 프로그래밍의 정도를 결정함.

프로세스 스케줄러는 선정한 작업의 상태를 변화시키며 프로세스의 생성에서 종료까지의 과정을 수행함.

실행 상태의 프로세스가 프로세서를 자발적으로 반환하기 전에 할당된 시간이 지나면 이 프로세스는 준비 상태가 됨.

그 후, 프로세스를 실행를 실행하다 입출력 명령(또는 시간이 많이 필요한 요청)이 발생하면 대기상 태가 됨.

대기 상태인 프로세스는 대기 원인을 제거하면 준비 상태로 바뀌고, 디스패처가 준비 상태인 프로세스에 프로세스를 할당하면 다시 실행 상태로 바뀜

##### 디스패치
스케줄러가 선택한 프로세스에 프로세서를 할당하는 모듈


##### 프로세스의 상태 변화
- 준비 -> 실행

프로세스가 프로세서를 점유하는 것(dispatch).

- 실행 -> 준비

인터럽트 클록(interrupt clock)을 두어 특정 프로세스가 할상된 시간 동안만 프로세스를 점유하게 하는 것.(timeout)

- 실행 -> 대기(보류)

할당된 시간 이전에 실행 상태의 프로세스에 입출력 연산 등이 필요하거나 새로운 자원 요청 등의 문제로 프로세를 양도하는 경우(block)

- 대기(보류) -> 준비

프로세스는 입출력이 지나면 깨움으로 대기에서 준비 상태가 됨.(wakeup)

#### 2.2) 프로세스 제어 블록
특정 프로세스 정보를 저장하는 블록이나 레코드(작업 제어 블록, TCB : Task Control Block)

프로세스가 생성되면 메모리에 프로세스 제어 블록을 생성하고, 프로세스가 실행을 종료하면 해당 프로세스 제어 블록도 삭제함.

운영체제의 모든 모듈이 프로제스 제어 블록의 정보를 읽고 수정할 수 있음.

#### 2.3) 프로세스의 문맥 교환
인터럽트나 시스템 호출 등으로 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것

프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용을 나중에 사용할 수 있도록 저장함.

## 2. 프로세스의 관리
### 1) 프로세스의 구조
프로세스는 실행 중에 프로세스 생성 시스템 호출을 이용하여 새로운 프로세스를 생성할 수 있음.

이때 프로세스 생성 순서를 저장하고 부모-자식 관계를 유지하여 계층적으로 생성함.

##### 부모 프로세스(parent process)
프로세스를 새로 생성하는 프로세스

##### 서브 프로세스(subprocess)/자식 프로세스(child process)
생성되는 자식 프로세스

부모 프로세스는 자식 프로세스를 생성하는 과정을 반복하며 계층 구조를 형성함.

### 2) 프로세스의 생성
운영체제나 응용 프로그램에서 프로세스를 생성 시, 해당 프로세스에서 PCB를 만들어 주소 공간을 할당함.

일괄 처리 환경에서는 준비 큐에 작업이 도착할 때 프로세스를 생성.

대화형 환경에서는 새로운 사용자가 로그온(log-on)할 때 프로세스를 생성

##### 프로세스를 생성할때 필요한 세부 작업
- 새로운 프로세스에 프로세스 식별자를 할당
- 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간을 할당함.
- 프로세스 제어 블록을 초기화함. 프로세스 상태, 프로그램 카운터 등 초기화, 자원 요청, 프로세스 제어 정보(우선순위) 등을 포함함.
- 링크를 건다(해당 큐에 삽입)

자식 프로세스는 운영체제나 부모 프로세스에서 자원을 사용함.

##### 프로세스가 새로운 프로세스를 생성할 때 가능한 경우
- 부모 프로세스와 자식 프로세스를 동시에 실행
- 부모 프로세스는 자식 프로세스를 모두 종료할 때까지 기다린다.

##### fork 명령어
- 부모와 동일한 자식을 복제
- fork 명령어를 호출한 후, exec 명령어를 연달아 호출하여 자식 프로세스의 주소 공간을 별도 프로그램 주소 공간으로 덮어쓰는 것

### 3) 프로세스의 종료
프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스의 삭제를 요청함

일괄 처리 환경에서는 작업 종료를 의미하는 신호로 인터럽터를 발생하거나 시스템 호출로 중단 명령을 전달하여 프로세스를 종료

대화형 환경에서는 사용자가 로그오프(log-off)하거나 터미널을 닫으면 프로세스를 종료

##### abort 명령어
종료할 프로세스의 부모 프로세스만 호출하는데, 부모가 아닌 다른 프로세스가 임의로 중단할 수 없기 때문

자식 프로세스는 종료할 때 자신의 식별자를 부모 프로세스에 전달

보통 부모 프로세스가 종료되면 자식 프로세스도 같이 종료됨.(연속 종료)

##### 프로세스의 종료 이유
- 정상종료

프로세스가 운영체제의 서비스를 호출할 때
- 시간초과

프로세스가 명시된 전체 시간을 초과하여 실행하거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다릴 때

- 실패

파일 검색 실패, 입출력이 명시된 횟수를 초과하여 실패할 때

- 산술 오류, 보호 오류, 데이터 오류 등
- 메모리 부족, 엑세스 위반 등

### 4) 프로세스의 제거
프로세스 제거는 프로세스를 파괴하는 것.

사용하던 자원을 시스템에 돌려주고 시스템 리스트나 테이블에서 사라져 PCB를 회수 당함.

단, 프로그램은 여전히 디스크에 저장한다. 그리고 자식 프로세스는 부모 프로세스를 제거하면 자동으로 제거됨.

### 5) 프로세스의 중단과 재시작

시스템의 유휴시간 문제는 프로세스 중단(일시정지) 상태를 이용하여 해결 가능.

시스템 전체의 부하를 증가시키지 않으면서 프로세스에 서비스를 제공할 수 있음.

다중 프로그래밍에서 중단은 자원 부족 상태를 의미하기도 함.

프로세스를 중단한 원인을 제거하여 다시 실행하는 것을 재시작이라고 함.

##### 프로세스의 중단과 재시작을 하는 경우
- 시스템에 장애가 발생하면 실행 중인 프로세스는 잠시 중단했다가 시스템이 기능을 회복할 때 다시 재시작할 수 있음
- 프로세스에 의심스러운 부분이 있으면 실행 중인 프로세스를 중단하여 확인한 후 재시작하거나 종료할 수 있음.
- 처리할 작업이 너무 많아 시스템에 시스템에 부담이 되면(너무 많은 적재) 프로세스 몇 개를 중단했다가 시스템이 정상 상태로 다시 돌아왓을 때 재시작할 수 있음

### 6) 프로세스의 우선순위 변경
프로세스 스케줄러는 PCB에 있는 우선수위를 이용해 준비 리스트의 프로세스를 처리

준비 리스트의 프로세스는 프로세서 중심 프로세스와 입출력 중심 프로세스로 구분할 수 있음.

입출력 중심 프로세스는 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스에 높은 우선순위를 부여하고 속도가 빠른 디스크 입출력 프로세스에는 낮은 우선순위를 부여

우선순위가 낮은 프로세스에는 시간을 많이 할당하고 우선순위가 높은 프로세스에는 시간을 적게 할당함

따라서 입출력 중심 프로세스는 프로세스를 짧게 자주 사용하도록 하고, 프로세서 중심 프로세스는 프로세서를 길게 사용하되 사용 횟수를 줄여 균형을 유지할 수 있음.

### 7) 프로세스의 문맥 교환
- 입출력 인터럽트

입출력 동작이 발생했음을 확인하고 이벤트를 기다리는 프로세스를 준비 상태로 바꾼 후 실행할 프로세스를 결정
- 클록 인터럽트

현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 바꾸고, 다른 프로세스를 실행 상태로 바꿈.

- Trap

부적절한 파일 접근이나 현재 실행 중인 프로세스 오류나 예외 상황으로 발생할 수 있음.

- 문맥 교환(context switching)
  
이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하여 프로세스를 교환하는 과정

## 3. 스레드의 개념과 상태 변화
### 1) 스레드의 개념

프로세스는 자원과 제어로 구분 가능

스레드 : 프로세스에서 제어만 분리한 실행 단위. 프로세스 하나에 한 개 이상의 스레드 존재 가능.

스레드들은 프로세스의 직접 실행 정보를 제외한 나머지 프로세스 관리 정보를 공유함.

보통 다른 프로시저를 호출하고 다른 실행을 기록함. 따라서 별도의 스택이 필요하며, 프로그램 카운터가 독립적이라서 같은 프로세스의 스레드들이 동시에 코드의 동일한 부분 실행 가능.

스레드는 관련 자원과 함께 메모리를 공유할 수 있으므로 손상된 데이터나 스레드의 이상 동작을 고려해야 함.

- 경량 프로세스(LWP: Light Weight Process)

프로세스의 속성 중 일부가 들어있는 것

- 중량 프로세스(HWP: Heavy Weight Process)

스레드 하나에 프로세스 하나인 전통적인 경우

같은 프로세스의 스레드들은 동일한 주소 공간을 공유하며 병렬로 수행함.

##### 스레드의 이점
- 사용자 응답성 증가

병렬 프로그래밍으로 계속 수행되어 사용자 응답성 증가.
- 프로세스의 자원과 메모리 공유 기능

동일한 주소 공간에서 스레드를 여러개 실행하여 시스템 성능 향상
- 경제성이 좋음

프로세스보다 스레드를 이용한 문맥 교환 시, 오버헤드가 줄어듬
- 다중 처리(멀티 프로세싱)로 성능과 효율 향상

### 2) 단일 스레드와 다중(멀티) 스레드
<그림 위치> - 별 내용 없음

### 3) 스레드의 사용 예
<그림 위치>

### 4) 스레드의 상태 변화
스레드는 프로세스처럼 준비, 실행, 대기(보류), 종료 상태가 있음

스레드는 프로세스를 함께 사용하고 항상 하나만 실행한다.

또 한 프로세스에 있는 스레드는 순차적으로 실행하고, 해당 스레드의 정보를 저장하는 레지스터와 스택이 존재함.

스레드 생성 시, 프로세스가 스택과 레지스터를 제공

스레드는 다른 스레드의 스택을 읽거나 덮어쓸 수 있음.
### 5)스레드의 제어 블록
TCB(Thread Control Block): 스레드 제어 블록

프로세스 제어 블록은 스레드 제어 블록의 리스트를 가리킴.(프로세스는 스레드의 집합이므로)

##### TCB의 내용
- 실행 상태 : 프로세서 레지스터, 프로그램 카운터, 스택 포인터
- 스케줄링 정보 : 상태(실행, 준비, 대기), 우선순위, 프로세서 시간
- 계정 정보
- 스케줄링 큐용 다양한 포인터
- 프로세스 제어 블록을 포함하는 포인터

## 4. 스레드의 구현
- 사용자 수준 스레드(user-level thread): 다대일(n:1) 매핑
- 커널 수준 스레드(kernel-level thread): 일대일(1:1) 매핑
- 혼합형 스레드(multiplexed thread): 다대다(n:m) 매핑

### 1) 사용자 수준 스레드
사용자 영역의 스레드 라이브러리로 구현. 

모든 행위는 사용자 영역에서 수행되므로 커널은 해당 스레드의 존재를 모름. 커널은 프로세스를 한 단위로 인식하고 프로세서를 할당.

##### 스레드 라이브러리
스레드의 생성과 종료, 스레드 간의 메시지 전달, 스레드의 스케줄링과 문맥 등 정보를 보관
##### 오버헤드
어떤 일을 처리하기 위해 들어가는 간접적인 시간 또는 메모리 등의 자원
##### 사용자 영역에서의 스레드 구현 장점
- 이식성이 높음 : 커널 독립적이므로 모든 운영체제에 적용 가능
- 오버헤드가 적음 : 스케줄링이나 동기화를 하기 위해 커널을 호출하지 않으므로 커널 영역으로 전환하는 오버헤드가 줄어듬.
- 유연한 스케줄링 가능 : 스레드 라이브러리에서 스레드 스케줄링을 제어하므로 응용 프로그램에 맞게 스케줄링 가능

##### 사용자 영역에서의 스레드 구현 단점
- 시스템의 동시성 미지원 : 프로세스 단위로 프로세서가 할당되어, 스레드 단위의 다중 처리 불가. 한 스레드가 대기 상태가 될 시 어떤 스레드도 실행이 불가능함.(순차적)
- 확장에 제약이 따름 : 다중 처리 시스템에서 규모 확장이 어려움(비동시적 = 순차적)
- 스레드 간 보호 불가능 : 스레드 간 보호에 커널의 보호 방법을 사용할 수 없음. 스레드 라이브러리에서 스레드 간 보호를 제공해야 프로세스 수준에서 보호가 가능함.

### 2) 커널 수준 스레드
사용자 수준 스레드의 한계를 극복하는 방법.

커널이 스레드와 관련된 모든 작업을 관리함(PCB와 TCB 유지)

스레드 한 개가 대기상태가 되면 다른 스레드로 교환이 가능.

커널 수준 스레드에서는 사용자 수준 스레드와 1:1 매핑 -> 사용자 수준 스레드 생성 시, 커널 스레드 자동 생성됨.

전체 프로세스와 스레즈 정보를 유지하여 오버헤드가 커짐. 

### 3) 혼합형 스레드
사용자 수준 스레드와 커널 수준 스레드의 혼합 구조

사용자 수준 스레드는 커널 수준 스레드와 비슷한 경량 프로세스에 다대다로 매핑되고, 경량 프로세스는 커널 수준 스레드와 일대일로 매핑됨.

커널 수준 스레드는 디스패치(프로세서 제어권 제공??)하고 스케줄링하여 프로세서에서 실행. 반면 경량 프로세스는 시스템 호출로 생성해서 커널 영역의 프로세스 문맥 안에서 실행하고, 커널로 독립적으로 스케줄링하여 다중 처리에서는 병렬로 실행함.

-ㅇ

프로세스에는 경량 프로세스가 하나 이상 존재하고, 경량 프로세스에는 이에 대응하는 커널 스레드가 한 개 있다.

그리고 자원과 입출력 대기를 하려고 경량 프로세스 단위로 대기하므로 프로세스는 입출력을 완료할 때까지 대기할 필요가 없음.

어떤 경량 프로세스가 입출력 완료를 기다리더라도 동일한 프로세스에서 다른 경량 프로세스를 실행할 수 있기 때문.

혼합형 스레드는 스레드 라이브러리가 최적의 성능을 지원하도록 커널이 경량 프로세스 수를 동적으로 조절하여 사용자 수준 스레드와 커널 수준 스레드가 다대다 매핑됨.

##### 스레드 풀링(Thread Pooling)
시스템이 관리하는 스레드의 풀(pool)을 응용 프로그램에 제공하여 스레드를 효율적으로 사용할 수 있게 하는 방법.

미리 생성한 스레드를 재사용하도록 하여 생성 시간 감소. 또 동시 생성 스레드 수를 제한히여 전체 성능 유지.

    